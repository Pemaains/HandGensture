
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gesture Particles - Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: monospace; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        /* Video is hidden by default to keep it clean, but you can see the overlay */
        #video-input { position: absolute; top: 10px; left: 10px; width: 160px; height: 120px; transform: scaleX(-1); opacity: 0.5; z-index: 2; border: 1px solid #333; }
        
        #ui { 
            position: absolute; bottom: 20px; left: 20px; color: white; z-index: 2; 
            pointer-events: none; background: rgba(0,0,0,0.6); padding: 15px; border-radius: 8px; border: 1px solid #333;
        }
        
        #debug-panel {
            position: absolute; top: 20px; right: 20px; color: #0f0; z-index: 2;
            background: rgba(0,0,0,0.8); padding: 10px; border-radius: 4px; font-size: 1.2rem; border: 1px solid #0f0;
        }

        h1 { margin: 0 0 10px 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; color: #00ffff; }
        #status-display { font-size: 1.1rem; font-weight: bold; color: #ff00ff; margin-bottom: 10px; border-bottom: 1px solid #555; padding-bottom: 5px; }
        .gesture-hint { font-size: 0.9rem; color: #ccc; margin-top: 4px; display: flex; align-items: center; gap: 8px;}
        .key { color: #aaa; min-width: 20px; }
    </style>
</head>
<body>

    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>

    <div id="debug-panel">
        Fingers: <span id="finger-count">0</span>
    </div>

    <div id="ui">
        <h1>Particle Shapes</h1>
        <div id="status-display">Loading AI...</div>
        
        <div class="gesture-hint"><span class="key">‚úä</span> <b>0</b> Fingers: Collapse</div>
        <div class="gesture-hint"><span class="key">‚òùÔ∏è</span> <b>1</b> Finger:  Heart</div>
        <div class="gesture-hint"><span class="key">‚úåÔ∏è</span> <b>2</b> Fingers: Saturn</div>
        <div class="gesture-hint"><span class="key">üëå</span> <b>3</b> Fingers: Flower</div>
        <div class="gesture-hint"><span class="key">üñêÔ∏è</span> <b>4</b> Fingers: Fireworks</div>
        <div class="gesture-hint"><span class="key">üñêÔ∏è</span> <b>5</b> Fingers: Sphere</div>
        <div style="margin-top:10px; color:#ff00ff; font-weight:bold;">ü§è Pinch Index+Thumb to Change Color</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        const loadScript = (src) => {
            return new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = src;
                s.onload = resolve;
                s.onerror = reject;
                document.head.appendChild(s);
            });
        };

        const CONFIG = {
            particleCount: 20000,
            particleSize: 0.1,
            lerpSpeed: 0.07, 
            pinchThreshold: 0.08 
        };

        let scene, camera, renderer, particles, geometry, material;
        let positions, colorsAttribute;
        let time = 0;
        let targetShape = 'sphere'; 
        let isPinching = false;
        
        const statusEl = document.getElementById('status-display');
        const countEl = document.getElementById('finger-count');
        const shapes = {};

        // --- 1. THREE.JS SETUP ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 8;
            camera.position.y = 1;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            initParticles();
            generateShapes();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        }

        function initParticles() {
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(CONFIG.particleCount * 3);
            const colors = new Float32Array(CONFIG.particleCount * 3);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 15;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 15;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 15;

                // Start Cyan
                colors[i * 3] = 0.0;
                colors[i * 3 + 1] = 1.0;
                colors[i * 3 + 2] = 1.0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');

            material = new THREE.PointsMaterial({
                size: CONFIG.particleSize,
                map: sprite,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function generateShapes() {
            const fill = (name, fn) => {
                const arr = new Float32Array(CONFIG.particleCount * 3);
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const p = fn(i);
                    arr[i * 3] = p.x;
                    arr[i * 3 + 1] = p.y;
                    arr[i * 3 + 2] = p.z;
                }
                shapes[name] = arr;
            };

            // Sphere
            fill('sphere', () => {
                const r = 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi) };
            });

            // Heart
            fill('heart', () => {
                const t = Math.random() * Math.PI * 2;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const scale = 0.2;
                return { x: x * scale, y: y * scale, z: (Math.random() - 0.5) * 4 };
            });

            // Saturn
            fill('saturn', (i) => {
                if (i % 3 === 0) { // Ring
                    const angle = Math.random() * Math.PI * 2;
                    const r = 3.5 + Math.random() * 2.5;
                    return { x: r * Math.cos(angle), y: (Math.random() - 0.5) * 0.2, z: r * Math.sin(angle) };
                } else { // Planet
                    const r = 2.0;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi) };
                }
            });

            // Flower
            fill('flower', () => {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                // Rose curve logic for 3D
                const r = 2 + Math.sin(5 * u) * Math.sin(5 * v); 
                return { 
                    x: r * Math.sin(v) * Math.cos(u), 
                    y: r * Math.sin(v) * Math.sin(u), 
                    z: r * Math.cos(v) 
                };
            });

            // Fireworks / Burst
            fill('fireworks', () => {
                 const r = 0.5 + Math.random() * 6; // Wide spread
                 const theta = Math.random() * Math.PI * 2;
                 const phi = Math.acos(2 * Math.random() - 1);
                 return {
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi)
                };
            });

            // Collapse
            fill('collapse', () => ({ x: (Math.random()-0.5)*0.5, y: (Math.random()-0.5)*0.5, z: (Math.random()-0.5)*0.5 }));
        }

        // --- 2. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.02;

            const positionsAttribute = geometry.attributes.position;
            colorsAttribute = geometry.attributes.color;
            const currentPos = positionsAttribute.array;
            const target = shapes[targetShape] || shapes['sphere'];

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;

                // Lerp Position
                currentPos[i3] += (target[i3] - currentPos[i3]) * CONFIG.lerpSpeed;
                currentPos[i3+1] += (target[i3+1] - currentPos[i3+1]) * CONFIG.lerpSpeed;
                currentPos[i3+2] += (target[i3+2] - currentPos[i3+2]) * CONFIG.lerpSpeed;

                // Motion
                if (targetShape !== 'collapse') {
                    // Wiggle effect
                    currentPos[i3] += Math.sin(time + currentPos[i3+1]) * 0.005;
                }

                // Color Logic
                if (isPinching) {
                    const hue = (time * 0.5 + (i * 0.00005)) % 1;
                    const c = new THREE.Color().setHSL(hue, 1.0, 0.5);
                    colorsAttribute.array[i3] = c.r;
                    colorsAttribute.array[i3+1] = c.g;
                    colorsAttribute.array[i3+2] = c.b;
                } else {
                    // Revert to Blue/Purple mix
                    colorsAttribute.array[i3] = THREE.MathUtils.lerp(colorsAttribute.array[i3], 0.2, 0.05);
                    colorsAttribute.array[i3+1] = THREE.MathUtils.lerp(colorsAttribute.array[i3+1], 0.8, 0.05);
                    colorsAttribute.array[i3+2] = THREE.MathUtils.lerp(colorsAttribute.array[i3+2], 1.0, 0.05);
                }
            }

            positionsAttribute.needsUpdate = true;
            colorsAttribute.needsUpdate = true; 
            particles.rotation.y += 0.002;
            renderer.render(scene, camera);
        }

        // --- 3. COMPUTER VISION ---
        async function initComputerVision() {
            await Promise.all([
                loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"),
                loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"),
                loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"),
                loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js")
            ]);

            const videoElement = document.getElementById('video-input');
            const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new window.Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240
            });
            cameraUtils.start();
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. Pinch Detection
                const pinchDist = Math.sqrt(
                    Math.pow(landmarks[4].x - landmarks[8].x, 2) + 
                    Math.pow(landmarks[4].y - landmarks[8].y, 2)
                );
                
                isPinching = pinchDist < CONFIG.pinchThreshold;

                if (isPinching) {
                    statusEl.innerText = "üåà PINCH: Colors!";
                    statusEl.style.color = "#ffff00";
                    return; // Exit so we don't switch shapes while pinching
                }

                // 2. Count Fingers (ROBUST METHOD)
                const count = countFingers(landmarks);
                countEl.innerText = count; // DEBUG UPDATE

                // 3. Shape Switcher
                if (count === 0) { targetShape = 'collapse'; statusEl.innerText = "‚úä COLLAPSE"; }
                else if (count === 1) { targetShape = 'heart'; statusEl.innerText = "‚òùÔ∏è HEART"; }
                else if (count === 2) { targetShape = 'saturn'; statusEl.innerText = "‚úåÔ∏è SATURN"; }
                else if (count === 3) { targetShape = 'flower'; statusEl.innerText = "üëå FLOWER"; }
                else if (count === 4) { targetShape = 'fireworks'; statusEl.innerText = "üñêÔ∏è FIREWORKS"; }
                else if (count >= 5) { targetShape = 'sphere'; statusEl.innerText = "üñêÔ∏è SPHERE"; }
                
                statusEl.style.color = "#00ffff";
            } else {
                statusEl.innerText = "Show Hand";
                countEl.innerText = "-";
            }
        }

        function countFingers(landmarks) {
            let count = 0;
            
            // THUMB: Check if tip is far from palm center (Landmark 9)
            // This works for both Left and Right hands better than X-coord checks
            const palmCenter = landmarks[9];
            const thumbTip = landmarks[4];
            const thumbBase = landmarks[2];
            
            // Simple distance check: Is tip further from center than the base is?
            const tipDist = Math.hypot(thumbTip.x - palmCenter.x, thumbTip.y - palmCenter.y);
            const baseDist = Math.hypot(thumbBase.x - palmCenter.x, thumbBase.y - palmCenter.y);
            
            if (tipDist > baseDist * 1.2) { 
                count++; 
            }

            // FINGERS: Check if Tip Y is above PIP Y (Y gets smaller as you go up screen)
            if (landmarks[8].y < landmarks[6].y) count++; // Index
            if (landmarks[12].y < landmarks[10].y) count++; // Middle
            if (landmarks[16].y < landmarks[14].y) count++; // Ring
            if (landmarks[20].y < landmarks[18].y) count++; // Pinky

            return count;
        }

        initThree();
        initComputerVision();

    </script>
</body>
</html>
